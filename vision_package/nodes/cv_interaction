#!/usr/bin/env python

import sys
import rospy
import cv2

from std_msgs.msg import String
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from geometry_msgs.msg import Pose


class FaceDetection:

    def __init__(self):

        # Load cascade configuration files
        # (currently saved in same directory as the node, to be moved into config)
        # self.faceCascade = cv2.CascadeClassifier("face_cascade.xml")
        self.faceCascade = cv2.CascadeClassifier(
            cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
        # self.eyeCascade  = cv2.CascadeClassifier("eye_cascade.xml")
        self.eyeCascade = cv2.CascadeClassifier(
            cv2.data.haarcascades + 'haarcascade_eye.xml')

        # Initialize CvBridge object, which allows conversion between ROS message
        # and OpenCV Image data type
        self.bridge = CvBridge()

        # Initialize subscriber, reading a ROS Image message type
        # (the topic will be published by the RealSense or the rosbag capture)
        self.image_sub = rospy.Subscriber('/camera/color/image_raw',
                                                 Image,
                                                 self.image_callback)
        self.state_sub = rospy.Subscriber('state', String, self.state_callback)
        self.pose_pub = rospy.Publisher('face_pose', Pose, queue_size=10)

        self.state = None

        self.dx = []
        self.dy = []
        self.lockonThreshold = 2   # Pixel hysteresis
        self.nSamples = 15         # Number of samples to track
        self.lastX = 0
        self.lastY = 0

    def state_callback(self, data):
        """ Used as the 'state' callback.

            Args:
               data (std_msgs/String): the current state
        """
        self.state = data.data

    def image_callback(self, data):
        """
        Callback for image subscriber
        """

        # Attempt to pull frame from ROS message
        try:
            # Pull image as an 8-bit RGB image
            self.incomingFrame = self.bridge.imgmsg_to_cv2(data, "bgr8")
        except CvBridgeError as e:
            # Print error if incoming frame cannot be pulled
            print(e)

        # Our operations on the frame come here
        # Use OpenCV to convert the incoming frame into a grayscale frame
        self.grayFrame = cv2.cvtColor(self.incomingFrame, cv2.COLOR_BGR2GRAY)

        # Run the face cascade and look for faces, then output the number of faces found
        self.faces = self.faceCascade.detectMultiScale(self.grayFrame, 1.3, 10)

        # Iterate over detected faces and draw a frame around each
        for (x, y, w, h) in self.faces:

            # Check length of dx and pop earliest element
            if len(self.dx) > self.nSamples:
                self.dx.pop(0)
            if len(self.dy) > self.nSamples:
                self.dy.pop(0)

        # Check if face has stabilized
        self.dx.append(abs(x - self.lastX))
        self.dy.append(abs(y - self.lastY))

        # Find average over last 10 frames
        self.dxAverage = sum(self.dx)/len(self.dx)
        self.dyAverage = sum(self.dy)/len(self.dy)

        # print ( "Average: " , self.dxAverage , ", " , self.dyAverage
        # Print centroid of detected faces in video pixel frame
        # print ( len(self.faces) , "face(s) found, centroid(s) at: " , x + (w / 2) , ", " , y + (h / 2))

        # Draw a blue frame
        if (self.dxAverage < self.lockonThreshold) and \
                (self.dxAverage < self.lockonThreshold):
            print("LOCK-ON ACHIEVED!")
            cv2.rectangle(self.incomingFrame, (x, y), (x+w, y+h), (0, 0, 255),
                          4)
            
            if self.state == "MOVE_TO_FACE":
            
                face_pose = Pose() 
                face_pose.x =   # TODO

                self.pose_pub.publish(face_pose)    

            
        else:
            cv2.rectangle(self.incomingFrame, (x, y), (x+w, y+h), (255, 0, 0),
                          2)

        self.lastX = x
        self.lastY = y

        # Highlight regions of interest (ROI)
        roi_gray = self.grayFrame[y:y+h, x:x+w]
        roi_color = self.incomingFrame[y:y+h, x:x+w]

        # Run eye cascade within the grayscale ROI
        eyes = self.eyeCascade.detectMultiScale(roi_gray)

        # Draw a green frame over the eyes
        for (ex, ey, ew, eh) in eyes:
            cv2.rectangle(roi_color, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 1)

        # # Display the image on the screen
        # cv2.imshow("Image window", self.incomingFrame)
        # cv2.waitKey(1)


def main(args):
    find_faces = FaceDetection()
    rospy.init_node('face_detection', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")
    cv2.destroyAllWindows()


if __name__ == '__main__':
    main(sys.argv)
