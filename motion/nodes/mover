#! usr/bin/env python3

"""
    Inverse Kinematics for Baxter end effector using moveit package 
"""
import sys
import rospy
import baxter_interface
from baxter_interface import CHECK_VERSION
import moveit_commander
from geometry_msgs.msg import Pose, PoseStamped, Point
from moveit_commander.conversions import pose_to_list, list_to_pose
from std_srvs.srv import Empty, EmptyResponse

class Mover(object):
    def __init__(self):
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        
        # arm groups
        self.left_arm_group = moveit_commander.MoveGroupCommander("left_arm", wait_for_servers=30)
        self.right_arm_group = moveit_commander.MoveGroupCommander("right_arm", wait_for_servers=30)
        
        #Go to Pose Service (For trial, can delete later)
        rospy.Service('/go_to_pose', Empty, self.go_to_pose_callback)
        #Reset Service:
        rospy.Service('/Reset', Empty,self.reset_callback)     
        #Read Position service:
        rospy.Service('/read_pose', Empty, self.read_pose_callback)
        #Step service
        rospy.Service('/Step', Step, self.step_callback)
        rospy.wait_for_service('step')
        self.step_service = rospy.ServiceProxy('step', Step)


        # Enable Robot 
        print("Getting robot state... ")
        self._rs = baxter_interface.RobotEnable(CHECK_VERSION)
        self._init_state = self._rs.state().enabled
        print("Enabling robot... ")
        self._rs.enable()
        self.planning_frame_left = self.left_arm_group.get_planning_frame()
        self.planning_frame_right = self.right_arm_group.get_planning_frame()
        self.add_wall()

    def wait_for_state_update(self, item_name, item_attached=False,
                              item_known=False, timeout=4):
        """ Ensures collision updates are received by waiting until changes
            are reflected in get_attached_objects() and
            get_known_object_names() lists.

            Taken from Interbotix MoveIt Tutorial's Python interface example.

            Args:
                item_name (string): name of item being added to planning scene
                item_attached (bool): whether item is already in
                                        get_attached_objects()
                item_known (bool): whether item is already in
                                        get_known_object_names()
                timeout (int): time limit if item can't be added
        """
        start = rospy.get_time()
        seconds = rospy.get_time()

        while (seconds - start < timeout) and not rospy.is_shutdown():

            attached_objects = self.scene.get_attached_objects([item_name])
            is_attached = len(attached_objects.keys()) > 0
            is_known = item_name in self.scene.get_known_object_names()

            if (item_attached == is_attached) and (item_known == is_known):
                return True

            rospy.sleep(0.1)
            seconds = rospy.get_time()

        return False

    def add_wall(self):
        wall_pose = PoseStamped()
        wall_pose.header.frame_id = self.planning_frame_right
        wall_pose.pose.position.x = 2
        self.scene.add_box('wall', wall_pose, size=(0.1, 0.5, 2))
        while not self.wait_for_state_update('wall', item_known=True):
            self.scene.add_box('wall', wall_pose, size=(0.1, 0.5, 2))
    
    def go_to_pose_callback(self, req):
        """
            Move to some position
        """
        left_current_pose = self.left_arm_group.get_current_pose(end_effector_link="left_gripper").pose
        # print(left_current_pose)
        left_target_pose = left_current_pose
        left_target_pose.position.x = left_current_pose.position.x + 0.2
        left_target_pose.position.z = left_current_pose.position.z + 0.2
        print(left_target_pose)
        

        # Set target
        print("Setting Target...")
        self.left_arm_group.set_pose_target(left_target_pose)

        # Plan 
        print("Planning...")
        success, traj, planTime, errCode = self.left_arm_group.plan()

        # Execute 
        print("Executing...")

        if not success:
            print("Error, planning failed")
        else:
            # self.left_arm_group.go(wait=True)
            self.left_arm_group.execute(traj)
            self.left_arm_group.stop()
        
        # Clear pose targets 
        self.left_arm_group.clear_pose_targets()

        return EmptyResponse()

    def read_pose_callback(self, req):
        """
        Reads the current pose of the right arm gripper
        """
        right_current_pose = self.right_arm_group.get_current_pose(end_effector_link="right_gripper").pose
        print(right_current_pose)
        return EmptyResponse()

    def reset_callback(self, req):
        """
        Moves the right arm to a default home state
        """
        #Declaring the reset position and assigning coordinates
        right_target_pose = Pose()
        right_target_pose.position.x = rospy.get_param("reset.p.x")
        right_target_pose.position.y = rospy.get_param("reset.p.y")
        right_target_pose.position.z = rospy.get_param("reset.p.z")
        right_target_pose.orientation.x = rospy.get_param("reset.o.x")
        right_target_pose.orientation.y = rospy.get_param("reset.o.y")
        right_target_pose.orientation.z = rospy.get_param("reset.o.z")
        right_target_pose.orientation.w = rospy.get_param("reset.o.w")

        #set target
        self.right_arm_group.set_pose_target(right_target_pose,end_effector_link="right_gripper")
        print(right_target_pose)
        print("Setting Target")

        #Can be done for left arm too
        """
        left_current_pose = self.left_arm_group.get_current_pose(end_effector_link="left_gripper").pose
        left_target_pose = left_current_pose
        left_target_pose.position.x = 0.26371349340013645
        left_target_pose.position.y = 1.091296894035553
        left_target_pose.position.z = 0.35912424523904696
        left_target_pose.orientation.x = -0.24796782188110464
        left_target_pose.orientation.y = 0.18128140465718853
        left_target_pose.orientation.z = 0.24710610580797293
        left_target_pose.orientation.w = 0.9190144634930815
        """
                
        # Plan 
        print("Planning...")
        success, traj, _, errCode = self.right_arm_group.plan()

        # Execute 
        print("Executing...")

        if not success:
            print("Error, planning failed")
            return EmptyResponse()
        else:
            self.right_arm_group.execute(traj)
            self.right_arm_group.stop()
            print("Success!")
        
        # Clear pose targets 
        self.right_arm_group.clear_pose_targets()

        return EmptyResponse()
    
    def step_callback(self, req):
        """
        Callback funtion for the step service. Takes the transforms/ coordinates from the vision package and directs the arm to go to the coordinates
        Args:
        req (arm_move/StepRequest):
        
        Returns:
        - (arm_move/StepResponse): MoveItErrorCode to indicate success or failure
        """
        pose_goal = req.pose_goal
        self.right_arm_group.set_pose_target(pose_goal)
        success, traj, _, errCode = self.right_arm_group.plan()

        if not success:
            return StepResponse(err_code=err_code)
        
        self.right_arm_group.execute(traj)
        self.right_arm_group.stop()
        self.right_arm_group.clear_pose_target()

        return StepResponse(err_code=err_code)



def main():
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node('moveit_mover')
    m = Mover()
    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass